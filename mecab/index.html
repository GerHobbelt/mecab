<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Mecab WebAssembly</title>
	<style>
		.emscripten { padding-right: 0; margin-left: auto; margin-right: auto; display: block; }
		div.emscripten { text-align: center; }      
		div.emscripten_border { border: 1px solid black; }
		/* the canvas *must not* have any border or padding, or mouse coords will be wrong */
		canvas.emscripten { border: 0px none; background-color: black; }
		
		.spinner {
			height: 30px;
			width: 30px;
			margin: 0;
			margin-top: 20px;
			margin-left: 20px;
			display: inline-block;
			vertical-align: top;
		
			-webkit-animation: rotation .8s linear infinite;
			-moz-animation: rotation .8s linear infinite;
			-o-animation: rotation .8s linear infinite;
			animation: rotation 0.8s linear infinite;
		
			border-left: 5px solid rgb(235, 235, 235);
			border-right: 5px solid rgb(235, 235, 235);
			border-bottom: 5px solid rgb(235, 235, 235);
			border-top: 5px solid rgb(120, 120, 120);
    	
			border-radius: 100%;
			background-color: rgb(189, 215, 46);
		}
		
		@-webkit-keyframes rotation {
			from {-webkit-transform: rotate(0deg);}
			to {-webkit-transform: rotate(360deg);}
		}
		@-moz-keyframes rotation {
			from {-moz-transform: rotate(0deg);}
			to {-moz-transform: rotate(360deg);}
		}
		@-o-keyframes rotation {
			from {-o-transform: rotate(0deg);}
			to {-o-transform: rotate(360deg);}
		}
		@keyframes rotation {
			from {transform: rotate(0deg);}
			to {transform: rotate(360deg);}
		}
		
		#status {
			display: inline-block;
			vertical-align: top;
			margin-top: 30px;
			margin-left: 20px;
			font-weight: bold;
			color: rgb(120, 120, 120);
		}
		
		#progress {
			height: 20px;
			width: 300px;
		}

		#output {
    	/*width: 100%;
    	height: 200px;*/
      width: 40em;
      height: 10em;

      border: black solid 1px;

    	/*margin: 0 auto;
    	margin-top: 10px;*/

      border-width: 1px;

    	/*border-left: 0px;
    	border-right: 0px;*/
    	padding-left: 0px;
    	padding-right: 0px;
    	display: block;
    	/*background-color: black;
    	color: white;*/
    	font-family: 'Lucida Console', Monaco, monospace;
    	outline: none;
      overflow-y: scroll;
      resize: both;
    }

    #input {
      width: 40em;
      height: 10em;
    }

    #args {
      width: 40em;
    }

    form input,form textarea {
      display: block;
    }

    #richOutput {
      margin-top: 1em;
      font-size: 18px;
      font-weight: 600;
    }
	</style>
  <script type="text/javascript">
/**
 * Returns detailed type as string (instead of just 'object' for arrays etc)
 * @private
 * @param {any} value js value
 * @returns {String} type of value
 * @example
 * typeOf({}); // 'object'
 * typeOf([]); // 'array'
 * typeOf(function() {}); // 'function'
 * typeOf(/a/); // 'regexp'
 * typeOf(new Date()); // 'date'
 * typeOf(null); // 'null'
 * typeOf(undefined); // 'undefined'
 * typeOf('a'); // 'string'
 * typeOf(1); // 'number'
 * typeOf(true); // 'boolean'
 * typeOf(new Map()); // 'map'
 * typeOf(new Set()); // 'map'
 */
function typeOf(value) {
  if (value === null) {
    return 'null';
  }
  if (value !== Object(value)) {
    return typeof value;
  }
  return {}.toString
    .call(value)
    .slice(8, -1)
    .toLowerCase();
}

/**
 * Checks if input string is empty
 * @param  {String} input text input
 * @return {Boolean} true if no input
 */
function isEmpty(input) {
  if (typeOf(input) !== 'string') {
    return true;
  }
  return !input.length;
}

/**
 * Takes a character and a unicode range. Returns true if the char is in the range.
 * @param  {String}  char  unicode character
 * @param  {Number}  start unicode start range
 * @param  {Number}  end   unicode end range
 * @return {Boolean}
 */
function isCharInRange(char = '', start, end) {
  if (isEmpty(char)) return false;
  const code = char.charCodeAt(0);
  return start <= code && code <= end;
}

const HIRAGANA_START = 0x3041;
const HIRAGANA_END = 0x3096;
const KATAKANA_START = 0x30a1;
const KATAKANA_END = 0x30fc;
const PROLONGED_SOUND_MARK = 0x30fc;
const KANA_SLASH_DOT = 0x30fb;
const ROMANIZATIONS = {
  HEPBURN: 'hepburn',
};

/**
 * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana).
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharHiragana(char = '') {
  if (isEmpty(char)) return false;
  if (isCharLongDash(char)) return true;
  return isCharInRange(char, HIRAGANA_START, HIRAGANA_END);
}

/**
 * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharKatakana(char = '') {
  return isCharInRange(char, KATAKANA_START, KATAKANA_END);
}

/**
 * Returns true if char is 'ー'
 * @param  {String} char to test
 * @return {Boolean}
 */
function isCharLongDash(char = '') {
  if (isEmpty(char)) return false;
  return char.charCodeAt(0) === PROLONGED_SOUND_MARK;
}

/**
 * Tests if char is '・'
 * @param  {String} char
 * @return {Boolean} true if '・'
 */
function isCharSlashDot(char = '') {
  if (isEmpty(char)) return false;
  return char.charCodeAt(0) === KANA_SLASH_DOT;
}

/**
 * Test if `input` is [Katakana](https://en.wikipedia.org/wiki/Katakana)
 * @param  {String} [input=''] text
 * @return {Boolean} true if all [Katakana](https://en.wikipedia.org/wiki/Katakana)
 * @example
 * isKatakana('ゲーム')
 * // => true
 * isKatakana('あ')
 * // => false
 * isKatakana('A')
 * // => false
 * isKatakana('あア')
 * // => false
 */
function isKatakana(input = '') {
  if (isEmpty(input)) return false;
  return [...input].every(isCharKatakana);
}

/**
 * Default config for WanaKana, user passed options will be merged with these
 * @type {DefaultOptions}
 * @name defaultOptions
 * @property {Boolean} [useObsoleteKana=false] - Set to true to use obsolete characters, such as ゐ and ゑ.
 * @example
 * toHiragana('we', { useObsoleteKana: true })
 * // => 'ゑ'
 * @property {Boolean} [passRomaji=false] - Set to true to pass romaji when using mixed syllabaries with toKatakana() or toHiragana()
 * @example
 * toHiragana('only convert the katakana: ヒラガナ', { passRomaji: true })
 * // => "only convert the katakana: ひらがな"
 * @property {Boolean} [upcaseKatakana=false] - Set to true to convert katakana to uppercase using toRomaji()
 * @example
 * toRomaji('ひらがな カタカナ', { upcaseKatakana: true })
 * // => "hiragana KATAKANA"
 * @property {Boolean|String} [IMEMode=false] - Set to true, 'toHiragana', or 'toKatakana' to handle conversion while it is being typed.
 * @property {String} [romanization='hepburn'] - choose toRomaji() romanization map (currently only 'hepburn')
 * @property {Object} [customKanaMapping] - custom map will be merged with default conversion
 * @example
 * toKana('wanakana', { customKanaMapping: { na: 'に', ka: 'Bana' }) };
 * // => 'わにBanaに'
 * @property {Object} [customRomajiMapping] - custom map will be merged with default conversion
 * @example
 * toRomaji('つじぎり', { customRomajiMapping: { じ: 'zi', つ: 'tu', り: 'li' }) };
 * // => 'tuzigili'
 */
const DEFAULT_OPTIONS = {
  useObsoleteKana: false,
  passRomaji: false,
  upcaseKatakana: false,
  ignoreCase: false,
  IMEMode: false,
  romanization: ROMANIZATIONS.HEPBURN,
};

const mergeWithDefaultOptions = (opts = {}) => Object.assign({}, DEFAULT_OPTIONS, opts);

/**
 * Convert kana to romaji
 * @param  {String} kana text input
 * @param  {DefaultOptions} [options=defaultOptions]
 * @return {String} converted text
 * @example
 * toRomaji('ひらがな　カタカナ')
 * // => 'hiragana katakana'
 * toRomaji('げーむ　ゲーム')
 * // => 'ge-mu geemu'
 * toRomaji('ひらがな　カタカナ', { upcaseKatakana: true })
 * // => 'hiragana KATAKANA'
 * toRomaji('つじぎり', { customRomajiMapping: { じ: 'zi', つ: 'tu', り: 'li' } });
 * // => 'tuzigili'
 */
function toRomaji(input = '', options = {}) {
  const mergedOptions = mergeWithDefaultOptions(options);
  // just throw away the substring index information and just concatenate all the kana
  return splitIntoRomaji(input, mergedOptions)
    .map((romajiToken) => {
      const [start, end, romaji] = romajiToken;
      const makeUpperCase = options.upcaseKatakana && isKatakana(input.slice(start, end));
      return makeUpperCase ? romaji.toUpperCase() : romaji;
    })
    .join('');
}

let customMapping = null;
function splitIntoRomaji(input, options) {
  let map = getKanaToRomajiTree(options);

  if (options.customRomajiMapping) {
    if (customMapping == null) {
      customMapping = mergeCustomMapping(map, options.customRomajiMapping);
    }
    map = customMapping;
  }

  return applyMapping(katakanaToHiragana(input, toRomaji, true), map, !options.IMEMode);
}

// transform the tree, so that for example hepburnTree['ゔ']['ぁ'][''] === 'va'
// or kanaTree['k']['y']['a'][''] === 'きゃ'
function transform(tree) {
  return Object.entries(tree).reduce((map, [char, subtree]) => {
    const endOfBranch = typeOf(subtree) === 'string';
    map[char] = endOfBranch ? { '': subtree } : transform(subtree);
    return map;
  }, {});
}

function getSubTreeOf(tree, string) {
  return string.split('').reduce((correctSubTree, char) => {
    if (correctSubTree[char] === undefined) {
      correctSubTree[char] = {};
    }
    return correctSubTree[char];
  }, tree);
}

function applyMapping(string, mapping, convertEnding) {
  const root = mapping;

  function nextSubtree(tree, nextChar) {
    const subtree = tree[nextChar];
    if (subtree === undefined) {
      return undefined;
    }
    // if the next child node does not have a node value, set its node value to the input
    return Object.assign({ '': tree[''] + nextChar }, tree[nextChar]);
  }

  function newChunk(remaining, currentCursor) {
    // start parsing a new chunk
    const firstChar = remaining.charAt(0);

    return parse(
      Object.assign({ '': firstChar }, root[firstChar]),
      remaining.slice(1),
      currentCursor,
      currentCursor + 1
    );
  }

  function parse(tree, remaining, lastCursor, currentCursor) {
    if (!remaining) {
      if (convertEnding || Object.keys(tree).length === 1) {
        // nothing more to consume, just commit the last chunk and return it
        // so as to not have an empty element at the end of the result
        return tree[''] ? [[lastCursor, currentCursor, tree['']]] : [];
      }
      // if we don't want to convert the ending, because there are still possible continuations
      // return null as the final node value
      return [[lastCursor, currentCursor, null]];
    }

    if (Object.keys(tree).length === 1) {
      return [[lastCursor, currentCursor, tree['']]].concat(newChunk(remaining, currentCursor));
    }

    const subtree = nextSubtree(tree, remaining.charAt(0));

    if (subtree === undefined) {
      return [[lastCursor, currentCursor, tree['']]].concat(newChunk(remaining, currentCursor));
    }
    // continue current branch
    return parse(subtree, remaining.slice(1), lastCursor, currentCursor + 1);
  }

  return newChunk(string, 0);
}

function mergeCustomMapping(map, customMapping) {
  if (!customMapping) {
    return map;
  }
  return typeOf(customMapping) === 'function'
    ? customMapping(map)
    : createCustomMapping(customMapping)(map);
}


let kanaToHepburnMap = null;

/* eslint-disable */
// prettier-ignore
const BASIC_ROMAJI = {
  あ:'a',    い:'i',   う:'u',   え:'e',    お:'o',
  か:'ka',   き:'ki',  く:'ku',  け:'ke',   こ:'ko',
  さ:'sa',   し:'shi', す:'su',  せ:'se',   そ:'so',
  た:'ta',   ち:'chi', つ:'tsu', て:'te',   と:'to',
  な:'na',   に:'ni',  ぬ:'nu',  ね:'ne',   の:'no',
  は:'ha',   ひ:'hi',  ふ:'fu',  へ:'he',   ほ:'ho',
  ま:'ma',   み:'mi',  む:'mu',  め:'me',   も:'mo',
  ら:'ra',   り:'ri',  る:'ru',  れ:'re',   ろ:'ro',
  や:'ya',   ゆ:'yu',  よ:'yo',
  わ:'wa',   ゐ:'wi',  ゑ:'we',  を:'wo',
  ん: 'n',
  が:'ga',   ぎ:'gi',  ぐ:'gu',  げ:'ge',   ご:'go',
  ざ:'za',   じ:'ji',  ず:'zu',  ぜ:'ze',   ぞ:'zo',
  だ:'da',   ぢ:'ji',  づ:'zu',  で:'de',   ど:'do',
  ば:'ba',   び:'bi',  ぶ:'bu',  べ:'be',   ぼ:'bo',
  ぱ:'pa',   ぴ:'pi',  ぷ:'pu',  ぺ:'pe',   ぽ:'po',
  ゔぁ:'va', ゔぃ:'vi', ゔ:'vu',  ゔぇ:'ve', ゔぉ:'vo',
};
/* eslint-enable  */

const SPECIAL_SYMBOLS = {
  '。': '.',
  '、': ',',
  '：': ':',
  '・': '/',
  '！': '!',
  '？': '?',
  '〜': '~',
  'ー': '-',
  '「': '‘',
  '」': '’',
  '『': '“',
  '』': '”',
  '［': '[',
  '］': ']',
  '（': '(',
  '）': ')',
  '｛': '{',
  '｝': '}',
  '　': ' ',
};

// んい -> n'i
const AMBIGUOUS_VOWELS = ['あ', 'い', 'う', 'え', 'お', 'や', 'ゆ', 'よ'];
const SMALL_Y = { ゃ: 'ya', ゅ: 'yu', ょ: 'yo' };
const SMALL_Y_EXTRA = { ぃ: 'yi', ぇ: 'ye' };
const SMALL_AIUEO = {
  ぁ: 'a',
  ぃ: 'i',
  ぅ: 'u',
  ぇ: 'e',
  ぉ: 'o',
};
const YOON_KANA = ['き', 'に', 'ひ', 'み', 'り', 'ぎ', 'び', 'ぴ', 'ゔ', 'く', 'ふ'];
const YOON_EXCEPTIONS = {
  し: 'sh',
  ち: 'ch',
  じ: 'j',
  ぢ: 'j',
};
const SMALL_KANA = {
  っ: '',
  ゃ: 'ya',
  ゅ: 'yu',
  ょ: 'yo',
  ぁ: 'a',
  ぃ: 'i',
  ぅ: 'u',
  ぇ: 'e',
  ぉ: 'o',
};

// going with the intuitive (yet incorrect) solution where っや -> yya and っぃ -> ii
// in other words, just assume the sokuon could have been applied to anything
const SOKUON_WHITELIST = {
  b: 'b',
  c: 't',
  d: 'd',
  f: 'f',
  g: 'g',
  h: 'h',
  j: 'j',
  k: 'k',
  m: 'm',
  p: 'p',
  q: 'q',
  r: 'r',
  s: 's',
  t: 't',
  v: 'v',
  w: 'w',
  x: 'x',
  z: 'z',
};

function getKanaToHepburnTree() {
  if (kanaToHepburnMap == null) {
    kanaToHepburnMap = createKanaToHepburnMap();
  }
  return kanaToHepburnMap;
}

function getKanaToRomajiTree(fullOptions) {
  switch (fullOptions.romanization) {
    case ROMANIZATIONS.HEPBURN:
      return getKanaToHepburnTree(fullOptions);
    default:
      return {};
  }
}

function createKanaToHepburnMap() {
  const romajiTree = transform(BASIC_ROMAJI);

  const subtreeOf = (string) => getSubTreeOf(romajiTree, string);
  const setTrans = (string, transliteration) => {
    subtreeOf(string)[''] = transliteration;
  };

  Object.entries(SPECIAL_SYMBOLS).forEach(([jsymbol, symbol]) => {
    subtreeOf(jsymbol)[''] = symbol;
  });

  [...Object.entries(SMALL_Y), ...Object.entries(SMALL_AIUEO)].forEach(([roma, kana]) => {
    setTrans(roma, kana);
  });

  // きゃ -> kya
  YOON_KANA.forEach((kana) => {
    const firstRomajiChar = subtreeOf(kana)[''][0];
    Object.entries(SMALL_Y).forEach(([yKana, yRoma]) => {
      setTrans(kana + yKana, firstRomajiChar + yRoma);
    });
    // きぃ -> kyi
    Object.entries(SMALL_Y_EXTRA).forEach(([yKana, yRoma]) => {
      setTrans(kana + yKana, firstRomajiChar + yRoma);
    });
  });

  Object.entries(YOON_EXCEPTIONS).forEach(([kana, roma]) => {
    // じゃ -> ja
    Object.entries(SMALL_Y).forEach(([yKana, yRoma]) => {
      setTrans(kana + yKana, roma + yRoma[1]);
    });
    // じぃ -> jyi, じぇ -> je
    setTrans(`${kana}ぃ`, `${roma}yi`);
    setTrans(`${kana}ぇ`, `${roma}e`);
  });

  romajiTree['っ'] = resolveTsu(romajiTree);

  Object.entries(SMALL_KANA).forEach(([kana, roma]) => {
    setTrans(kana, roma);
  });

  AMBIGUOUS_VOWELS.forEach((kana) => {
    setTrans(`ん${kana}`, `n'${subtreeOf(kana)['']}`);
  });

  // NOTE: could be re-enabled with an option?
  // // んば -> mbo
  // const LABIAL = [
  //   'ば', 'び', 'ぶ', 'べ', 'ぼ',
  //   'ぱ', 'ぴ', 'ぷ', 'ぺ', 'ぽ',
  //   'ま', 'み', 'む', 'め', 'も',
  // ];
  // LABIAL.forEach((kana) => {
  //   setTrans(`ん${kana}`, `m${subtreeOf(kana)['']}`);
  // });

  return Object.freeze(JSON.parse(JSON.stringify(romajiTree)));
}

function resolveTsu(tree) {
  return Object.entries(tree).reduce((tsuTree, [key, value]) => {
    if (!key) {
      // we have reached the bottom of this branch
      const consonant = value.charAt(0);
      tsuTree[key] = Object.keys(SOKUON_WHITELIST).includes(consonant)
        ? SOKUON_WHITELIST[consonant] + value
        : value;
    } else {
      // more subtrees
      tsuTree[key] = resolveTsu(value);
    }
    return tsuTree;
  }, {});
}


//--------

const isCharInitialLongDash = (char, index) => isCharLongDash(char) && index < 1;
const isCharInnerLongDash = (char, index) => isCharLongDash(char) && index > 0;
const isKanaAsSymbol = (char) => ['ヶ', 'ヵ'].includes(char);
const LONG_VOWELS = {
  a: 'あ',
  i: 'い',
  u: 'う',
  e: 'え',
  o: 'う',
};

// inject toRomaji to avoid circular dependency between toRomaji <-> katakanaToHiragana
function katakanaToHiragana(input = '', toRomaji, isDestinationRomaji) {
  let previousKana = '';

  return input
    .split('')
    .reduce((hira, char, index) => {
      // Short circuit to avoid incorrect codeshift for 'ー' and '・'
      if (isCharSlashDot(char) || isCharInitialLongDash(char, index) || isKanaAsSymbol(char)) {
        return hira.concat(char);
        // Transform long vowels: 'オー' to 'おう'
      } else if (previousKana && isCharInnerLongDash(char, index)) {
        // Transform previousKana back to romaji, and slice off the vowel
        const romaji = toRomaji(previousKana).slice(-1);
        // However, ensure 'オー' => 'おお' => 'oo' if this is a transform on the way to romaji
        if (isCharKatakana(input[index - 1]) && romaji === 'o' && isDestinationRomaji) {
          return hira.concat('お');
        }
        return hira.concat(LONG_VOWELS[romaji]);
      } else if (!isCharLongDash(char) && isCharKatakana(char)) {
        // Shift charcode.
        const code = char.charCodeAt(0) + (HIRAGANA_START - KATAKANA_START);
        const hiraChar = String.fromCharCode(code);
        previousKana = hiraChar;
        return hira.concat(hiraChar);
      }
      // Pass non katakana chars through
      previousKana = '';
      return hira.concat(char);
    }, [])
    .join('');
}
Object.assign(window, {
  katakanaToHiragana,
  toRomaji,
  isCharHiragana,
});
  </script>
</head>
<body>
	<div class="spinner" id='spinner'></div>
    <div class="emscripten" id="status">Downloading...</div>

	<div class="emscripten">
      <progress value="0" max="100" id="progress" hidden=1></progress>
    </div>

    <h1>MeCab &mdash; WebAssembly</h1>
    <p><a href="https://taku910.github.io/mecab/">MeCab, the Japanese morphological analyser by Taku Kudo</a> compiled by Alex Birch to WebAssembly (based on <a href="https://github.com/fasiha/mecab-emscripten">emscripten example by fasiha</a>). Using <a href="https://ja.osdn.net/projects/naist-jdic/wiki/FrontPage">NAIST-jdic</a> dictionary.</p>
    <!-- <div class="emscripten_border">
      <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" tabindex=-1></canvas>
    </div> -->
    <form id="form">
        <!-- <input id="args" name="args" value="-o output.txt input.txt" placeholder="-o output.txt input.txt"> -->
        <textarea id="input" name="input">
太郎はこの本を二郎を見た女性に渡した。
すもももももももものうち。
</textarea>
        <input id="submitter" type="submit">
    </form>
    <!-- <pre id="output"></pre> -->
    <div id="richOutput"></div>

    <script type='text/javascript'>
      const statusElement = document.getElementById('status');
      const progressElement = document.getElementById('progress');
      const spinnerElement = document.getElementById('spinner');
      const outputElement = document.getElementById('output');
      const richOutputElement = document.getElementById('richOutput');
      const wrapped = {};
      const toBeFreed = {
        mecab_model_t: new Set(), // config
        mecab_t: new Set(), // tagger
        mecab_lattice_t: new Set(),
      };
      let p_currentTagger;
      let p_currentLattice;

      function partition(readingHiragana, token) {
        // iterate backwards through the chars in the token
        // for (let i = token.length-1, char = token[i]; i >= 0; i--) {
        //   if (!window.isCharHiragana(char)) {
        //     return readingHiragana.substring(0, i);
        //   }
        // }
        // iterate backwards through the chars in the token
        let [prefix, hiraganaTail] = ['', token];
        for (let i = token.length-1; i >= 0; i--) {
          const char = token[i];
          if (!window.isCharHiragana(char)) {
            [prefix, hiraganaTail] = [token.substring(0, i+1), token.substring(i+1)];
            break;
          }
        }
        // console.log([prefix, hiraganaTail])
        for (let i = readingHiragana.length-1, hiraganaTailIx = 0; i >= 0; i--, hiraganaTailIx++) {
          const char = readingHiragana[i];
          if (char !== hiraganaTail[hiraganaTailIx]) {
            return [prefix, hiraganaTail, readingHiragana.substring(0, i+1)];
          }
        }
        return [prefix, hiraganaTail, ''];
      }

      function parse(sentence) {
        const output = wrapped.mecab_sparse_tostr(p_currentTagger, sentence);
        console.log(output);
        return output.replace(/EOS\n$/, '')
        .split('\n')
        .filter(x => x)
        .map((line) => {
          const [token, featureStr] = line.split('\t');
          const features = featureStr.split(',');
          // MeCab seems to have a non-guaranteed schema
          while (features.length <= 9) {
            features.push('');
          }
          const [
          surfaceLayerForm, // 表層形
          partOfSpeech, // 品詞
          partOfSpeechSubcategory1, // 品詞細分類1
          partOfSpeechSubcategory2, // 品詞細分類2
          partOfSpeechSubcategory3, // 品詞細分類3
          utilizationType, // 活用型
          dictionaryForm, // 活用形
          originalForm, // 原形
          reading, // 読み
          pronunication, // 発音
          ] = features;
          const readingHiragana = window.katakanaToHiragana(reading, toRomaji, false)
          const [prefix, kanaTail, readingHiraganaWithoutKanaTail] = partition(readingHiragana, token);
          return {
            token,
            surfaceLayerForm,
            partOfSpeech,
            partOfSpeechSubcategory1,
            partOfSpeechSubcategory2,
            partOfSpeechSubcategory3,
            utilizationType,
            dictionaryForm,
            originalForm,
            reading,
            readingHiragana,
            prefix,
            kanaTail,
            readingHiraganaWithoutKanaTail,
            pronunication,
          }
        });
      }

      function createAnalysisFragment(nodes) {
        const fragment = document.createDocumentFragment();
        const div = document.createElement('div');
        for (const node of nodes) {
          if (node.readingHiraganaWithoutKanaTail
            && node.readingHiraganaWithoutKanaTail !== node.token
            && node.prefix) {
            const ruby = document.createElement('ruby');
            const rt = document.createElement('rt');

            // for some reason, in order for the rt to appear:
            // a space is required at the end of the ruby text
            ruby.insertAdjacentText('afterbegin', node.prefix);
            rt.insertAdjacentText('afterbegin', node.readingHiraganaWithoutKanaTail);
            ruby.appendChild(rt);
            div.appendChild(ruby);
            // div.appendChild(document.createTextNode(node.kanaTail));
            div.appendChild(document.createTextNode(`${node.kanaTail || ''} `));
          } else {
            div.insertAdjacentText('beforeend', `${node.token} ` );
          }
        }
        fragment.appendChild(div);
        return fragment;
      }

      document.getElementById('form').addEventListener('submit', function(event) {
        event.preventDefault();
        const input = document.getElementById('input').value;
        const nodes = parse(input);
        console.warn(nodes);
        // const pretty = nodes.map((node) => node.token).join('\n');
        // outputElement.insertAdjacentText('beforeend', `${pretty}\n`);
        // outputElement.scrollTop = outputElement.scrollHeight;

        const fragment = createAnalysisFragment(nodes);
        richOutput.prepend(fragment);
      }, true);

      const dicdir = '/naist-jdic';

      var Module = {
      	noInitialRun: true,
      	onRuntimeInitialized: function() {
          statusElement.style.display = 'none';
      	},
        locateFile: function(path, prefix) {
          console.log(path, prefix);
          // // if it's a mem init file, use a custom dir
          // if (path.endsWith(".mem")) return "https://mycdn.com/memory-init-dir/" + path;
          // otherwise, use the default, the prefix (JS file's dir) + the path
          return prefix + path;
        },
        preRun: [function() {
          FS.createPath('/', 'usr/local/etc')
          FS.writeFile('/usr/local/etc/mecabrc', `\
;
; Configuration file of MeCab
;
; $Id: mecabrc.in,v 1.3 2006/05/29 15:36:08 taku-ku Exp $;
;
dicdir = ${dicdir}

; userdic = /home/foo/bar/user.dic

; output-format-type = wakati
; input-buffer-size = 8192

; node-format = %m\n
; bos-format = %S\n
; eos-format = EOS\n
`);
        }],
        postRun: [function() {
          Object.assign(wrapped, {
            mecab_do: Module.cwrap('mecab_do2', 'number', ['string']),
            mecab_model_new2: Module.cwrap('mecab_model_new2', 'number', ['string']),
            mecab_model_destroy: Module.cwrap('mecab_model_destroy', null, ['number']),
            mecab_strerror: Module.cwrap('mecab_strerror', 'string', ['number']),
            mecab_model_new_tagger: Module.cwrap('mecab_model_new_tagger', 'number', ['number']),
            mecab_destroy: Module.cwrap('mecab_destroy', null, ['number']),
            mecab_nbest_sparse_tostr: Module.cwrap('mecab_nbest_sparse_tostr', 'string', ['number', 'number', 'string']),
            mecab_sparse_tostr: Module.cwrap('mecab_sparse_tostr', 'string', ['number', 'string']),
          });

          // we could probably skip the destroy since the world's ending anyway..
          Module.addOnExit(() => {
            toBeFreed.mecab_t.forEach((p_mecab_t) => {
              wrapped.mecab_destroy(p_mecab_t);
            });
            toBeFreed.mecab_model_t.forEach((p_mecab_model_t) => {
              wrapped.mecab_model_destroy(p_mecab_model_t);
            });
          });

          // const args = document.getElementById('args').value;
          // const args = '-o output.txt input.txt';
          const args = '';
          const p_mecab_model = wrapped.mecab_model_new2(args);
          toBeFreed.mecab_model_t.add(p_mecab_model);

          const p_tagger = wrapped.mecab_model_new_tagger(p_mecab_model);
          toBeFreed.mecab_t.add(p_tagger);

          p_currentTagger = p_tagger;

          document.getElementById('submitter').click();
        }],
        print: (function() {
          // var element = document.getElementById('output');
          // if (element) element.value = ''; // clear browser cache
          // return function(text) {
          //   if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
          //   // These replacements are necessary if you render to raw HTML
          //   //text = text.replace(/&/g, "&amp;");
          //   //text = text.replace(/</g, "&lt;");
          //   //text = text.replace(/>/g, "&gt;");
          //   //text = text.replace('\n', '<br>', 'g');
          //   console.log(text);
          //   if (element) {
          //     element.value += text + "\n";
          //     element.scrollTop = element.scrollHeight; // focus on bottom
          //   }
          // };
            return function(text) {
              if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
              console.log(text);
              // FS.writeFile('output.txt', parts);
              const outputElem = document.getElementById('output');
              outputElem.insertAdjacentText('beforeend', `${text}\n`);
              outputElem.scrollTop = outputElem.scrollHeight
            };
        })(),
        printErr: function(text) {
          if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
          console.error(text);
        },
        // canvas: (function() {
        //   var canvas = document.getElementById('canvas');

        //   // As a default initial behavior, pop up an alert when webgl context is lost. To make your
        //   // application robust, you may want to override this behavior before shipping!
        //   // See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15.2
        //   canvas.addEventListener("webglcontextlost", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);

        //   return canvas;
        // })(),
        setStatus: function(text) {
          if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };
          if (text === Module.setStatus.last.text) return;
          var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
          var now = Date.now();
          if (m && now - Module.setStatus.last.time < 30) return; // if this is a progress update, skip it if too soon
          Module.setStatus.last.time = now;
          Module.setStatus.last.text = text;
          if (m) {
            text = m[1];
            progressElement.value = parseInt(m[2])*100;
            progressElement.max = parseInt(m[4])*100;
            progressElement.hidden = false;
            spinnerElement.hidden = false;
          } else {
            progressElement.value = null;
            progressElement.max = null;
            progressElement.hidden = true;
            if (!text) spinnerElement.style.display = 'none';
          }
          statusElement.innerHTML = text;
        },
        totalDependencies: 0,
        monitorRunDependencies: function(left) {
          this.totalDependencies = Math.max(this.totalDependencies, left);
          Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
        }
      };
      Module.setStatus('Downloading...');
      window.onerror = function(event) {
        // TODO: do not warn on ok events like simulating an infinite loop or exitStatus
        Module.setStatus('Exception thrown, see JavaScript console');
        spinnerElement.style.display = 'none';
        Module.setStatus = function(text) {
          if (text) Module.printErr('[post-exception status] ' + text);
        };
      };
    </script>
    <script async type="text/javascript" src="mecab.js"></script>
</body>
</html>